---
title: Stages
sidebar: reference
permalink: reference/build/stages.html
---

## Проблематика

Что _обычно_ нужно запустить во время сборки?

* добавить код
* установить системное ПО
* установить системные зависимости
* установить прикладные зависимости
* настроить системное ПО
* настроить приложение

В каком порядке нужно выполнять эти шаги, чтобы сборка была быстрой, а _пересборка_ не занимала лишнего места? 

Нужно разделить сборку на более крупные шаги с чётким назначением. В dapp такие шаги называются стадиями.

## What is stage?

Стадии - это основной инструмент для ускорения сборки.
Стадия (stage) — это сгруппированный набор инструкций для сборки docker образа.
* Стадии заданы статически.
    * Предопределены имена стадий.
    * Предопределен порядок следования стадий.
    * См. [конвейер стадий](#конвейер-стадий).
* В результате сборки стадии создается отдельный docker образ.
* Имя docker образа стадии формируется по шаблону: dimgstage-\<имя проекта\>:\<[cигнатура стадии](#сигнатура-стадии)\>.
* Собранный образ dimg представляет собой связанный список docker образов стадий.
* Стадия может быть пропущена, если для нее не указано инструкций.
    * Для такой стадии не будет существовать отдельный docker образ.
    * См. [cигнатура стадии](#сигнатура-стадии).
* **Всю магию работы со стадиями делает за вас dapp, вам нужно только правильно прописать инструкции по сборке.**

## Stage signature

Сигнатура стадии (stage signature) — это контрольная сумма правил сборки, зависимостей стадии и сигнатуры предыдущей стадии, если она существует.

* Изменение сигнатуры стадии ведет к её пересборке, а также к пересборке последующих стадий.
* При отсутствии правил и зависимостей, стадия игнорируется, используется сигнатура предыдущей стадии.

## What is stage conveyor?

Конвейер стадий — это статически определенная последовательность стадий для сборки определенного типа образов. Существуют следующие конвейеры стадий:

* конвейер стадий dimg;
* конвейер стадий артефакта;

## Порядок сборки

Действия по сборке выполняются по порядку стадий на диаграмме. То есть сначала docker.from, затем команды, определённые для стадии before_install, затем install, потом before_setup и, наконец, setup. После чего выполняются docker.* директивы. Результат выполнения каждой стадии это docker-образ. Т.е. стадия install создаётся на основе образа, созданного на стадии before_install и так далее. Забегая вперёд, нужно упомянуть, что у каждой стадии есть контрольная сумма, вычисляемая из команд, которые определены для стадии (похоже на чексумму директив Dockerfile). Если команды стадии изменились, то изменится чексумма и приложение будет пересобрано начиная с изменившейся стадии (опять же аналогично сборке на основе Dockerfile). Нужно повысить версию imagemagick? Значит изменится install и пересоберутся стадии install, before_setup, setup, docker_instructions.

Итоговая диаграмма выглядит так:

![Диаграмма пользовательских стадий сборки]({{ site.baseurl }}/images/build/stages_02.png "Диаграмма пользовательских стадий сборки")

В дальнейшем эта диаграмма будет расширена, т.к.[артефакт]({{ site.baseurl }}/reference/dappfile/artifact_directive.html) или dimod (модули chef) добавляют свои стадии. Но пока можно перейти к главе про [shell-сборщик](shell_builder.html), чтобы увидеть стадии в работе.

### Состояния стадий

* EMPTY

  Стадия пустая, не используются [связанные директивы]({{ site.baseurl }}/not_used/stages_diagram.html).
  
  К примеру, git artifact стадии считаются пустыми, если при описании приложения в dappfile не были использованы git-artifact-ы ([git]({{ site.baseurl }}/reference/dappfile/git_directive.html)), аналогичная ситуация с artifact-ами ([artifact]({{ site.baseurl }}/reference/dappfile/artifact_directive.html)) и пользовательскими стадиями.

* BUILD

  Стадия готова к сборке.

* REBUILD

  Стадия должна быть пересобрана. Текущая стадия собрана (связанный образ существует), но выполняется условие, при котором она считается невалидной, или необходимо пересобрать одну из предшествующих стадий.
  
  К примеру, g_a_dependencies стадия может содержать комиты, которые несуществуют в git-репозиториях, был выполнен rebase. Необходимо пересобрать текущую и все последующие стадии, чтобы избежать падения при сборке g_a стадий.

* USING_CACHE

  Стадия собрана.

* NOT_PRESENT

  Стадия не собрана и может не собираться, так как при сборке последующих стадий нет потребности в собранном образе текущей.
  
  Таким образом, при распределённой сборке достаточно скачать из registry верхний доступный кэш.
